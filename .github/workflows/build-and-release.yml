name: Build and Release

on:
  push:
    branches:
      - "main"
      - "dev"
    paths-ignore:
      - '*.md'
      - 'images/**'
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ main, dev ]
    paths-ignore:
      - '*.md'
      - 'images/**'

jobs:
  build:
    runs-on: self-hosted
    if: github.event_name != 'pull_request'
    outputs:
      should_release: ${{ steps.check_release.outputs.should_release }}
      tag: ${{ steps.version.outputs.tag }}
      branch: ${{ steps.version.outputs.branch }}
      release_type: ${{ steps.version.outputs.release_type }}
      docker_tag: ${{ steps.docker_tags.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Cache pip packages
        # Skip cache for self-hosted runners (files persist locally)
        if: ${{ runner.name != 'git01' }}
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            /root/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      - name: Determine Docker tags and cache
        id: docker_tags
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          
          if [ "$BRANCH_NAME" = "main" ]; then
            echo "tag=latest" >> $GITHUB_OUTPUT
            echo "cache_key=${{ runner.os }}-buildx-main-${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "cache_restore=${{ runner.os }}-buildx-main-" >> $GITHUB_OUTPUT
          else
            echo "tag=dev" >> $GITHUB_OUTPUT
            echo "cache_key=${{ runner.os }}-buildx-dev-${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "cache_restore=${{ runner.os }}-buildx-dev-" >> $GITHUB_OUTPUT
          fi
      
      - name: Cache Docker layers
        # Skip GitHub Actions cache for self-hosted runners (files persist locally)
        if: ${{ runner.name != 'git01' }}
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ steps.docker_tags.outputs.cache_key }}
          restore-keys: |
            ${{ steps.docker_tags.outputs.cache_restore }}
            ${{ runner.os }}-buildx-
      
      - name: Determine if release should be created
        id: check_release
        run: |
          # Create release on push to main or dev branch
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            if [ "$BRANCH_NAME" = "main" ]; then
              echo "üì¶ Release will be created (push to main)"
            else
              echo "üì¶ Test release will be created (push to $BRANCH_NAME)"
            fi
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "üî® Build only (no release)"
          fi
      
      - name: Get version tag for release
        id: version
        if: steps.check_release.outputs.should_release == 'true'
        run: |
          # Fetch all tags to ensure we have complete tag history
          git fetch --tags --force
          
          # Determine branch-specific tag prefix
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          echo "Branch: $BRANCH_NAME"
          
          if [ "$BRANCH_NAME" = "main" ]; then
            TAG_PREFIX="v"
            TAG_PATTERN="v[0-9]*.[0-9]*"
            RELEASE_TYPE="stable"
          else
            TAG_PREFIX="v-${BRANCH_NAME}-"
            TAG_PATTERN="v-${BRANCH_NAME}-[0-9]*.[0-9]*"
            RELEASE_TYPE="test"
          fi
          
          # Get all matching tags and find the highest version
          echo "Looking for tags matching pattern: ${TAG_PATTERN}"
          LATEST_TAG=$(git tag -l "${TAG_PATTERN}" | sort -V | tail -n1)
          
          if [ -z "$LATEST_TAG" ]; then
            # No existing tags, start at 0.1
            MAJOR=0
            MINOR=0
            echo "No existing tags found, starting at ${TAG_PREFIX}0.1"
          else
            echo "Latest tag: $LATEST_TAG"
            # Extract version numbers (remove prefix first)
            VERSION="${LATEST_TAG#${TAG_PREFIX}}"
            IFS='.' read -ra PARTS <<< "$VERSION"
            MAJOR=${PARTS[0]:-0}
            MINOR=${PARTS[1]:-0}
            echo "Current version: $MAJOR.$MINOR"
          fi
          
          # Increment minor version by 1 (0.1 increments)
          MINOR=$((MINOR + 1))
          NEW_TAG="${TAG_PREFIX}${MAJOR}.${MINOR}"
          
          # Ensure the new tag doesn't already exist (keep incrementing if it does)
          ATTEMPTS=0
          while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
            echo "‚ö†Ô∏è Tag $NEW_TAG already exists, incrementing..."
            MINOR=$((MINOR + 1))
            NEW_TAG="${TAG_PREFIX}${MAJOR}.${MINOR}"
            ATTEMPTS=$((ATTEMPTS + 1))
            if [ $ATTEMPTS -gt 100 ]; then
              echo "‚ùå Error: Too many version increment attempts"
              exit 1
            fi
          done
          
          echo "‚úÖ New tag: $NEW_TAG"
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
      
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ vars.DOCKERHUB_USERNAME }}/simpleclouddetect:${{ steps.docker_tags.outputs.tag }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          platforms: linux/amd64,linux/arm64
      
      - name: Move cache
        if: always()
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      
      - name: Docker Hub Description
        if: github.ref == 'refs/heads/main'
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          repository: ${{ vars.DOCKERHUB_USERNAME }}/simpleclouddetect
          short-description: "ML-based cloud detection for AllSky cameras with MQTT and ASCOM Alpaca"
          readme-filepath: ./readme.md
      
      - name: Get image size
        if: github.ref == 'refs/heads/dev'
        run: |
          docker pull ${{ vars.DOCKERHUB_USERNAME }}/simpleclouddetect:${{ steps.docker_tags.outputs.tag }}
          IMAGE_SIZE=$(docker images --format "{{.Size}}" ${{ vars.DOCKERHUB_USERNAME }}/simpleclouddetect:${{ steps.docker_tags.outputs.tag }} | head -n1)
          echo "Docker image size: $IMAGE_SIZE"

  release:
    needs: build
    if: needs.build.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Generate commit history
      id: changelog
      run: |
        # Get the previous tag for this branch (excluding the tag we're about to create)
        BRANCH_NAME="${{ needs.build.outputs.branch }}"
        
        if [ "$BRANCH_NAME" = "main" ]; then
          TAG_PREFIX="v"
          TAG_PATTERN="${TAG_PREFIX}*"
        else
          TAG_PREFIX="v-${BRANCH_NAME}-"
          TAG_PATTERN="${TAG_PREFIX}*"
        fi
        
        NEW_TAG="${{ needs.build.outputs.tag }}"
        
        # Get all matching tags, exclude the new tag if it exists, and get the latest
        PREVIOUS_TAG=$(git tag -l "${TAG_PATTERN}" | grep -v "^${NEW_TAG}$" | sort -V | tail -n1)
        
        if [ -z "$PREVIOUS_TAG" ]; then
          echo "No previous tag found, showing last 20 commits"
          COMMITS=$(git log -20 --pretty=format:"- %s (%h)" --no-merges)
        else
          echo "Generating changelog from $PREVIOUS_TAG to HEAD"
          COMMITS=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          
          # If no commits found, it means we're on the same commit
          if [ -z "$COMMITS" ]; then
            echo "No new commits since $PREVIOUS_TAG"
            COMMITS="- No changes since previous release"
          fi
        fi
        
        # Save to output using heredoc to handle multiline
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMITS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
    
    - name: Create and push tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Check if tag exists (should not happen due to version increment logic)
        if git rev-parse "${{ needs.build.outputs.tag }}" >/dev/null 2>&1; then
          echo "‚ùå Error: Tag ${{ needs.build.outputs.tag }} already exists"
          echo "This should not happen - version increment logic failed"
          exit 1
        else
          git tag ${{ needs.build.outputs.tag }}
          git push origin ${{ needs.build.outputs.tag }}
          echo "‚úÖ Created and pushed tag ${{ needs.build.outputs.tag }}"
        fi
    
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.build.outputs.tag }}
        name: ${{ needs.build.outputs.release_type == 'test' && format('üß™ Test Release {0} ({1} branch)', needs.build.outputs.tag, needs.build.outputs.branch) || format('Release {0}', needs.build.outputs.tag) }}
        prerelease: ${{ needs.build.outputs.release_type == 'test' }}
        files: |
          README.md
          ALPACA_README.md
        body: |
          ${{ needs.build.outputs.release_type == 'test' && '## üß™ Test Release' || '## üì¶ SimpleCloudDetect' }}
          ${{ needs.build.outputs.tag }}
          
          ${{ needs.build.outputs.release_type == 'test' && format('‚ö†Ô∏è **This is a pre-release test build from the `{0}` branch.**', needs.build.outputs.branch) || '' }}
          ${{ needs.build.outputs.release_type == 'test' && '**Use for testing purposes only. For stable releases, use builds from the main branch.**' || '' }}
          ${{ needs.build.outputs.release_type == 'test' && '' || 'ML-based cloud detection for AllSky cameras with MQTT and ASCOM Alpaca SafetyMonitor support.' }}
          
          ### üöÄ Installation Methods
          
          #### Docker (Recommended)
          ```bash
          docker pull ${{ vars.DOCKERHUB_USERNAME }}/simpleclouddetect:${{ needs.build.outputs.docker_tag }}
          ```
          
          #### Docker Compose
          ${{ needs.build.outputs.release_type == 'test' && format('Update your docker-compose.yml to use the `{0}` tag:', needs.build.outputs.docker_tag) || 'See [README.md](README.md) for complete Docker Compose setup instructions.' }}
          ${{ needs.build.outputs.release_type == 'test' && '```yaml' || '' }}
          ${{ needs.build.outputs.release_type == 'test' && format('image: {0}/simpleclouddetect:{1}', vars.DOCKERHUB_USERNAME, needs.build.outputs.docker_tag) || '' }}
          ${{ needs.build.outputs.release_type == 'test' && '```' || '' }}
          
          ### Key Features
          - **ML-Based Cloud Detection**: Accurate sky condition classification using TensorFlow Lite
          - **ASCOM Alpaca Integration**: Full SafetyMonitor device support for astronomy automation
          - **MQTT Support**: Home Assistant auto-discovery and custom MQTT topics
          - **Multi-Platform**: Docker images for AMD64 and ARM64 (Raspberry Pi)
          - **Web Interface**: Configuration and monitoring via web UI
          - **Configurable Safety Thresholds**: Per-class confidence levels and debounce timers
          - **Latest Detection Image Thumbnail**: Visual confirmation on setup page
          
          ### Documentation
          - [README.md](README.md) - Complete setup and features
          - [ALPACA_README.md](ALPACA_README.md) - ASCOM Alpaca integration guide
          
          ### Changes in This Release
          ${{ steps.changelog.outputs.changelog || '_No commits found_' }}
          
          ### Docker Image
          ```bash
          docker pull ${{ vars.DOCKERHUB_USERNAME }}/simpleclouddetect:${{ needs.build.outputs.docker_tag }}
          ```
          
          **Multi-platform support:**
          - `linux/amd64` - x86_64 systems
          - `linux/arm64` - Raspberry Pi 3/4/5, ARM64 systems
          ${{ needs.build.outputs.release_type == 'test' && format('
          **Branch**: {0}', needs.build.outputs.branch) || '' }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  pr-commit-summary:
    name: Generate PR Summary
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Collect commit information
        id: collect
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching commits for PR #${{ github.event.pull_request.number }}"
          
          # Get detailed commit information
          gh pr view ${{ github.event.pull_request.number }} --json commits \
            --jq '.commits[] | "**Commit \(.oid[0:7])** by \(.authors[0].name // "Unknown")\nMessage: \(.messageHeadline)\n\(.messageBody // "")\n---"' \
            > commits.txt
          
          # Get changed files with stats
          gh pr view ${{ github.event.pull_request.number }} --json files \
            --jq '.files[] | "- `\(.path)` (+\(.additions)/-\(.deletions))"' \
            > files.txt
          
          # Get changed files excluding GitHub workflows (for AI summary)
          gh pr view ${{ github.event.pull_request.number }} --json files \
            --jq '.files[] | select(.path | startswith(".github/workflows/") | not) | "- `\(.path)` (+\(.additions)/-\(.deletions))"' \
            > files_for_ai.txt
          
          # Check if changes are only in GitHub Actions workflows
          NON_WORKFLOW_CHANGES=$(gh pr view ${{ github.event.pull_request.number }} --json files \
            --jq '[.files[] | select(.path | startswith(".github/workflows/") | not)] | length')
          
          if [ "$NON_WORKFLOW_CHANGES" -eq 0 ]; then
            echo "skip_summary=true" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Skipping AI summary - changes are only in GitHub Actions workflows"
          else
            echo "skip_summary=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Will generate AI summary for code changes (excluding workflow files)"
          fi
          
          # Get commit count
          COMMIT_COUNT=$(gh pr view ${{ github.event.pull_request.number }} --json commits --jq '.commits | length')
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          
          echo "Collected $COMMIT_COUNT commits"

      - name: Generate summary with Google Gemini
        id: summarize
        if: steps.collect.outputs.skip_summary == 'false'
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
        run: |
          set +e  # Don't exit immediately on error
          
          # Read collected data
          COMMITS=$(cat commits.txt)
          FILES=$(cat files_for_ai.txt)
          
          # Escape special characters for JSON
          COMMITS_ESCAPED=$(echo "$COMMITS" | jq -Rs .)
          FILES_ESCAPED=$(echo "$FILES" | jq -Rs .)
          PR_TITLE=$(echo "${{ github.event.pull_request.title }}" | jq -Rs .)
          PR_BODY=$(echo "${{ github.event.pull_request.body }}" | jq -Rs .)
          
          # Build the prompt
          read -r -d '' PROMPT << 'EOF'
          You are a code review assistant. Analyze the following pull request and provide a comprehensive summary.

          **IMPORTANT:** Focus ONLY on the actual code changes listed below. Do NOT mention or summarize any GitHub Actions workflow files (.github/workflows/) as those have been filtered out.

          ## Pull Request Details
          **Title:** %PR_TITLE%
          **Description:** %PR_BODY%

          ## Commits in this PR
          %COMMITS%

          ## Files Changed (excluding workflow files)
          %FILES%

          ## Your Task
          Provide a well-structured summary with these sections:

          ### üìã Overview
          Write 2-3 sentences describing what this PR accomplishes overall.

          ### üîÑ Changes by Category
          Group the changes into relevant categories such as:
          - **Features**: New functionality added
          - **Bug Fixes**: Issues resolved
          - **Refactoring**: Code improvements without behavior changes
          - **Documentation**: README, comments, docs updates
          - **Tests**: Test additions or modifications
          - **Dependencies**: Package or dependency changes
          - **Configuration**: Config file changes

          Only include categories that apply. Use bullet points for each change.

          ### ‚ö†Ô∏è Notable Details
          Highlight any:
          - Breaking changes
          - Security considerations
          - Performance implications
          - Migration requirements

          If none, write "No notable concerns identified."

          ### üëÄ Suggested Review Focus
          List 2-4 specific areas or files reviewers should pay close attention to.

          Format everything in clean markdown.
          EOF
          
          # Replace placeholders (remove jq quotes)
          PROMPT="${PROMPT//%PR_TITLE%/$(echo $PR_TITLE | jq -r .)}"
          PROMPT="${PROMPT//%PR_BODY%/$(echo $PR_BODY | jq -r .)}"
          PROMPT="${PROMPT//%COMMITS%/$(echo $COMMITS_ESCAPED | jq -r .)}"
          PROMPT="${PROMPT//%FILES%/$(echo $FILES_ESCAPED | jq -r .)}"
          
          # Make API request to Google Gemini
          RESPONSE=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent" \
            -H "Content-Type: application/json" \
            -H "X-goog-api-key: $GOOGLE_API_KEY" \
            -d "$(jq -n \
              --arg prompt "$PROMPT" \
              '{
                contents: [
                  {
                    parts: [
                      {
                        text: $prompt
                      }
                    ]
                  }
                ],
                generationConfig: {
                  temperature: 0.3,
                  maxOutputTokens: 8192
                }
              }')")
          
          # Check for errors
          if [ -z "$RESPONSE" ]; then
            echo "‚ùå Error: Empty response from API"
            exit 1
          fi
          
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ùå Error from API:"
            echo "$RESPONSE" | jq '.'
            exit 1
          fi
          
          if ! echo "$RESPONSE" | jq -e '.candidates[0].content.parts[0].text' > /dev/null 2>&1; then
            echo "‚ùå Invalid response structure"
            exit 1
          fi
          
          # Extract summary
          echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text' > summary.md

      - name: Update PR body with summary
        if: steps.collect.outputs.skip_summary == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read the generated summary
            const summary = fs.readFileSync('summary.md', 'utf8');
            const commitCount = '${{ steps.collect.outputs.commit_count }}';
            const timestamp = new Date().toISOString();
            
            // Get current PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            // Create enhanced PR body with AI summary
            const marker = '<!-- pr-commit-summary-bot -->';
            const summarySection = `${marker}
            
            ${summary}
            
            ---
            <sub>üìä Analyzed **${commitCount}** commit(s) | üïê Updated: ${timestamp} | Generated by GitHub Actions</sub>
            
            ---
            `;
            
            // Check if the PR body already has our summary marker
            let newBody;
            if (pr.body && pr.body.includes(marker)) {
              // Replace existing summary section
              const markerIndex = pr.body.indexOf(marker);
              const endMarkerIndex = pr.body.indexOf('---\n\n', markerIndex + summarySection.length);
              
              if (endMarkerIndex !== -1) {
                // Replace everything from marker to the end of summary section
                newBody = pr.body.substring(0, markerIndex) + summarySection + pr.body.substring(endMarkerIndex + 5);
              } else {
                // Fallback: append new summary
                newBody = summarySection + (pr.body || '');
              }
            } else {
              // Prepend summary to existing body
              newBody = summarySection + (pr.body || '');
            }
            
            // Update the PR
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: newBody
            });
            
            console.log(`‚úÖ Updated PR #${context.issue.number}`);

